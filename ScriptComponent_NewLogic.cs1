/* SSIS Script Component - Ultra Stable Version 
   Compatible with SQL 2017 (No additional DLL references needed)
*/

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;
using System.Text.RegularExpressions;

public class ScriptMain : UserComponent
{
    private List<ApiTaskItem> _pendingTasks = new List<ApiTaskItem>();

    private class ApiTaskItem
    {
        public int Id { get; set; }
        public string ConstructedUrl { get; set; }
        public string MaxDistanceValue { get; set; }
    }

    public override void PreExecute()
    {
        base.PreExecute();
        // 強制使用 TLS 1.2，這對 SQL 2017 連結現代 API 至關重要
        ServicePointManager.SecurityProtocol = (SecurityProtocolType)3072;
        // 增加連線限制
        ServicePointManager.DefaultConnectionLimit = 100;
    }

    public override void Input0_ProcessInputRow(Input0Buffer Row)
    {
        // 1. 使用 Regex 從你的 JSON 文字中提取座標 (與之前邏輯相同)
        string pattern = @"""Value"":""([\d\.-]+,[\d\.-]+)""";
        var matches = Regex.Matches(Row.JsonColumn, pattern);
        
        List<string> locs = new List<string>();
        foreach (Match m in matches)
        {
            locs.Add("loc=" + m.Groups[1].Value);
        }

        string finalUrl = "http://mapcaldistacne/hosting?" + string.Join("&", locs);
        _pendingTasks.Add(new ApiTaskItem { Id = Row.ID, ConstructedUrl = finalUrl });
    }

    public override void CreateNewOutputRows()
    {
        // 2. 執行非同步請求 (雖然 WebClient 是同步的，但我們用 Task.Run 讓它並行)
        RunParallelRequests();

        // 3. 輸出結果
        foreach (var task in _pendingTasks)
        {
            Output0Buffer.AddRow();
            Output0Buffer.OutID = task.Id;
            Output0Buffer.MaxDistance = task.MaxDistanceValue;
        }
    }

private void RunParallelRequests()
{
    var options = new ParallelOptions { MaxDegreeOfParallelism = 20 };

    Parallel.ForEach(_pendingTasks, options, (item) =>
    {
        try
        {
            // 使用我們自定義的帶有 Timeout 的版本
            using (var client = new WebClientWithTimeout())
            {
                // 現在如果 API 超過 30 秒沒回傳，會直接跳到 catch
                string responseBody = client.DownloadString(item.ConstructedUrl);
                item.MaxDistanceValue = GetMaxDistanceByRegex(responseBody);
            }
        }
        catch (WebException webEx)
        {
            // 如果是 Timeout，這裡會捕捉到
            item.MaxDistanceValue = "Timeout/Network Error: " + webEx.Status;
        }
        catch (Exception ex)
        {
            item.MaxDistanceValue = "Error: " + ex.Message;
        }
    });
}

    private string GetMaxDistanceByRegex(string json)
    {
        // 從回傳的 JSON 提取最大 distance
        string pattern = @"""distance"":\s*""?([\d\.]+)""?";
        var matches = Regex.Matches(json, pattern);
        
        double max = -1;
        foreach (Match m in matches)
        {
            if (double.TryParse(m.Groups[1].Value, out double val))
            {
                if (val > max) max = val;
            }
        }
        return max == -1 ? "0" : max.ToString();
    }
}

/* 1. 定義一個帶有 Timeout 功能的 WebClient */
private class WebClientWithTimeout : WebClient
{
    protected override WebRequest GetWebRequest(Uri address)
    {
        WebRequest request = base.GetWebRequest(address);
        if (request != null)
        {
            // 設定 Timeout 時間（單位：毫秒）
            // 例如 30000 代表 30 秒
            request.Timeout = 30000; 
        }
        return request;
    }
}
