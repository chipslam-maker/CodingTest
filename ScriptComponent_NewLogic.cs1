/* SSIS Script Component - Advanced JSON Parsing & Async Parallel HTTP
   Optimized for: Multi-loc GPS extraction and batch API calls
*/

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;
using System.Text;
using Newtonsoft.Json.Linq;

public class ScriptMain : UserComponent
{
    private static readonly HttpClient httpClient;
    private List<ApiTaskItem> _pendingTasks = new List<ApiTaskItem>();

    static ScriptMain()
    {
        ServicePointManager.DefaultConnectionLimit = 100;
        ServicePointManager.Expect100Continue = false;
        ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

        httpClient = new HttpClient();
        httpClient.Timeout = TimeSpan.FromMinutes(3);
    }

    private class ApiTaskItem
    {
        public int Id { get; set; }
        public string ConstructedUrl { get; set; }
        public string MaxDistanceValue { get; set; }
    }

    public override void Input0_ProcessInputRow(Input0Buffer Row)
    {
        try
        {
            // 1. Parse the input JSON text to extract GPS coordinates
            string jsonInput = Row.JsonColumn; // 假設你的輸入欄位叫 JsonColumn
            string urlParameters = ExtractLocParameters(jsonInput);

            // 2. Combine with Base URL
            string baseUrl = "http://mapcaldistacne/hosting?";
            string finalUrl = baseUrl + urlParameters;

            _pendingTasks.Add(new ApiTaskItem
            {
                Id = Row.ID,
                ConstructedUrl = finalUrl
            });
        }
        catch (Exception ex)
        {
            // If JSON parsing fails before request
            _pendingTasks.Add(new ApiTaskItem
            {
                Id = Row.ID,
                MaxDistanceValue = "Pre-processing Error: " + ex.Message
            });
        }
    }

    // Helper method to parse your specific JSON structure from the image
    private string ExtractLocParameters(string jsonText)
    {
        JArray items = JArray.Parse(jsonText);
        List<string> locs = new List<string>();

        foreach (var item in items)
        {
            if (item["Key"]?.ToString() == "loc")
            {
                // Access the nested Value object's Value field
                string gpsCoord = item["Value"]?["Value"]?.ToString();
                if (!string.IsNullOrEmpty(gpsCoord))
                {
                    locs.Add("loc=" + gpsCoord);
                }
            }
        }

        // Joins them with '&' to create: loc=52.65,1.26&loc=52.65,1.26...
        return string.Join("&", locs);
    }

    public override void CreateNewOutputRows()
    {
        // Execute HTTP requests in parallel
        RunParallelRequestsAsync().Wait();

        // Output results
        foreach (var task in _pendingTasks)
        {
            Output0Buffer.AddRow();
            Output0Buffer.OutID = task.Id;
            Output0Buffer.MaxDistance = task.MaxDistanceValue;
        }
    }

    private async Task RunParallelRequestsAsync()
    {
        using (SemaphoreSlim semaphore = new SemaphoreSlim(20))
        {
            var tasks = _pendingTasks.Where(t => t.MaxDistanceValue == null).Select(async item =>
            {
                await semaphore.WaitAsync();
                try
                {
                    var response = await httpClient.GetAsync(item.ConstructedUrl);
                    if (response.IsSuccessStatusCode)
                    {
                        string responseJson = await response.Content.ReadAsStringAsync();
                        item.MaxDistanceValue = ParseMaxDistance(responseJson);
                    }
                    else
                    {
                        item.MaxDistanceValue = "HTTP_" + (int)response.StatusCode;
                    }
                }
                catch (Exception ex)
                {
                    item.MaxDistanceValue = "Network Error: " + ex.Message;
                }
                finally
                {
                    semaphore.Release();
                }
            });

            await Task.WhenAll(tasks);
        }
    }

    private string ParseMaxDistance(string json)
    {
        try
        {
            JObject data = JObject.Parse(json);
            var distances = data.SelectTokens("..distance")
                                .Select(t => (double)t)
                                .ToList();

            return distances.Any() ? distances.Max().ToString() : "0";
        }
        catch { return "Parse Error"; }
    }
}
